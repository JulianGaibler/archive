#!/usr/bin/env node

/**
 * Interactive Environment Setup Script
 * Helps users set up environment variables with migration support
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import crypto from 'crypto';
import { input, select, confirm } from '@inquirer/prompts';
import chalk from 'chalk';
import {
  ENV_VERSION,
  ENV_VARIABLES,
  getVariablesForMode,
  getVariablesByCategory,
  getDefault,
  getSmartDefault,
  isRequired,
  validateVariable
} from './env-config.js';
import {
  detectEnvVersion,
  needsMigration,
  migrateEnv,
  detectMode
} from './migrations/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.join(__dirname, '..');

/**
 * Parse command line arguments
 */
function parseArgs() {
  const args = process.argv.slice(2);
  const options = {};

  for (const arg of args) {
    if (arg.startsWith('--mode=')) {
      options.mode = arg.split('=')[1];
    }
  }

  return options;
}

/**
 * Parse existing .env file into object
 * @param {string} filePath
 * @returns {Object}
 */
function parseEnvFile(filePath) {
  if (!fs.existsSync(filePath)) {
    return {};
  }

  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n');
    const vars = {};

    for (const line of lines) {
      const trimmed = line.trim();

      // Skip comments and empty lines
      if (!trimmed || trimmed.startsWith('#')) {
        continue;
      }

      // Parse KEY=VALUE
      const match = trimmed.match(/^([A-Z_][A-Z0-9_]*)=(.*)$/);
      if (match) {
        const [, key, value] = match;
        vars[key] = value;
      }
    }

    return vars;
  } catch (error) {
    throw new Error(`Failed to parse ${filePath}: ${error.message}`);
  }
}

/**
 * Generate .env file content
 * @param {Object} values - Variable values
 * @param {'development' | 'production'} mode
 * @returns {string}
 */
function generateEnvFile(values, mode) {
  const modeLabel = mode === 'development' ? 'Development' : 'Production';

  let content = `# ENV_VERSION=${ENV_VERSION}
# ${modeLabel} Environment Variables
# Generated by setup script

`;

  const grouped = getVariablesByCategory(mode);
  const categories = Object.keys(grouped);

  for (const category of categories) {
    const variables = grouped[category];

    content += `# ${category}\n`;

    for (const variable of variables) {
      const value = values[variable.name] || '';
      content += `${variable.name}=${value}\n`;
    }

    content += '\n';
  }

  return content.trim() + '\n';
}

/**
 * Prompt for a single variable
 * @param {Object} variable
 * @param {'development' | 'production'} mode
 * @param {string} existingValue - Value from migration or existing file
 * @param {Object} collectedValues - Values collected so far for smart suggestions
 * @returns {Promise<string>}
 */
async function promptForVariable(variable, mode, existingValue = null, collectedValues = {}) {
  const defaultValue = existingValue || await getSmartDefault(variable, collectedValues, mode);
  const required = isRequired(variable, mode);

  // Build the message
  let message = variable.longDescription || variable.description;
  if (required) {
    message += chalk.red(' (required)');
  } else {
    message += chalk.gray(' (optional)');
  }

  // Handle different input types
  if (variable.type === 'enum' && variable.prompt && variable.prompt.choices) {
    const value = await select({
      message: `${variable.name}: ${message}`,
      choices: variable.prompt.choices.map(c => ({
        name: c.label,
        value: c.value
      })),
      default: defaultValue
    });
    return value;
  } else {
    // Regular input with validation loop
    let value;
    while (true) {
      value = await input({
        message: `${variable.name}: ${message}`,
        default: defaultValue || ''
      });

      // Skip validation for optional empty values
      if (!required && !value) {
        return value;
      }

      // Validate
      const validation = validateVariable(variable, value, mode);
      if (validation === true) {
        return value;
      } else {
        console.log(chalk.red(`  ‚úó ${validation}`));
      }
    }
  }
}

/**
 * Main setup flow
 */
async function main() {
  console.log(chalk.bold.blue('\nüîß Environment Setup Tool\n'));

  const cmdArgs = parseArgs();

  try {
    // Step 1: Ask for mode (or use from command line)
    let mode = cmdArgs.mode;

    if (!mode) {
      mode = await select({
        message: 'Select environment mode:',
        choices: [
          { name: 'Development', value: 'development' },
          { name: 'Production', value: 'production' }
        ]
      });
    }

    if (!['development', 'production'].includes(mode)) {
      console.error(chalk.red('Invalid mode. Must be "development" or "production"'));
      process.exit(1);
    }

    const fileExt = mode === 'development' ? 'dev' : 'prod';
    const envFilePath = path.join(ROOT_DIR, `.env.${fileExt}`);

    console.log(chalk.gray(`\nTarget file: ${envFilePath}\n`));

    // Step 2: Check for existing file
    let existingVars = {};
    let migratedVars = {};
    let migrationChanges = [];

    if (fs.existsSync(envFilePath)) {
      console.log(chalk.yellow('Existing environment file found.'));

      const currentVersion = detectEnvVersion(envFilePath);
      const versionLabel = currentVersion || 'unversioned (assumed v1.0.0)';
      console.log(chalk.gray(`Current version: ${versionLabel}`));
      console.log(chalk.gray(`Target version: ${ENV_VERSION}\n`));

      if (needsMigration(currentVersion, ENV_VERSION)) {
        // Offer migration
        const choice = await select({
          message: 'What would you like to do?',
          choices: [
            { name: 'Migrate existing file to new version', value: 'migrate' },
            { name: 'Start fresh (backup existing file)', value: 'fresh' },
            { name: 'Cancel', value: 'cancel' }
          ]
        });

        if (choice === 'cancel') {
          console.log(chalk.gray('Setup cancelled.'));
          process.exit(0);
        }

        if (choice === 'migrate') {
          // Parse existing file
          existingVars = parseEnvFile(envFilePath);

          // Detect mode from existing variables if not obvious
          const detectedMode = detectMode(existingVars);
          if (detectedMode !== mode) {
            console.log(chalk.yellow(
              `\nWarning: Detected mode "${detectedMode}" from existing file, but you selected "${mode}"`
            ));
            const proceed = await confirm({
              message: 'Continue with selected mode?',
              default: true
            });
            if (!proceed) {
              console.log(chalk.gray('Setup cancelled.'));
              process.exit(0);
            }
          }

          // Apply migration
          console.log(chalk.blue('\nüîÑ Applying automatic migration...\n'));
          const result = migrateEnv(existingVars, currentVersion, ENV_VERSION, mode);
          migratedVars = result.migrated;
          migrationChanges = result.changes;

          if (migrationChanges.length > 0) {
            console.log(chalk.green('Migration changes:'));
            for (const change of migrationChanges) {
              console.log(chalk.gray(`  ‚Ä¢ ${change}`));
            }
            console.log();
          } else {
            console.log(chalk.gray('No migration changes needed.\n'));
          }

          // Backup original file
          const backupPath = `${envFilePath}.backup.${Date.now()}`;
          fs.copyFileSync(envFilePath, backupPath);
          console.log(chalk.gray(`Backup saved to: ${backupPath}\n`));
        } else {
          // Start fresh - backup existing
          const backupPath = `${envFilePath}.backup.${Date.now()}`;
          fs.copyFileSync(envFilePath, backupPath);
          console.log(chalk.gray(`Backup saved to: ${backupPath}\n`));
        }
      } else {
        // File is up to date or newer
        if (currentVersion && currentVersion !== ENV_VERSION) {
          console.log(chalk.red(
            `\nError: Environment file version (${currentVersion}) is newer than script version (${ENV_VERSION})`
          ));
          console.log(chalk.red('Please update the setup script or manually edit the file.'));
          process.exit(1);
        }

        // Offer to update existing file
        const choice = await select({
          message: 'File is up to date. What would you like to do?',
          choices: [
            { name: 'Review and update values', value: 'update' },
            { name: 'Start fresh (backup existing file)', value: 'fresh' },
            { name: 'Cancel', value: 'cancel' }
          ]
        });

        if (choice === 'cancel') {
          console.log(chalk.gray('Setup cancelled.'));
          process.exit(0);
        }

        if (choice === 'update') {
          existingVars = parseEnvFile(envFilePath);
          migratedVars = existingVars;

          // Backup original file
          const backupPath = `${envFilePath}.backup.${Date.now()}`;
          fs.copyFileSync(envFilePath, backupPath);
          console.log(chalk.gray(`Backup saved to: ${backupPath}\n`));
        } else {
          // Start fresh - backup existing
          const backupPath = `${envFilePath}.backup.${Date.now()}`;
          fs.copyFileSync(envFilePath, backupPath);
          console.log(chalk.gray(`Backup saved to: ${backupPath}\n`));
        }
      }
    }

    // Step 3: Prompt for variables
    console.log(chalk.bold.blue('üìù Configure environment variables\n'));

    const values = {};
    const grouped = getVariablesByCategory(mode);
    const categories = Object.keys(grouped);

    for (const category of categories) {
      console.log(chalk.bold.cyan(`\n${category}`));
      console.log(chalk.gray('‚îÄ'.repeat(50)));

      const variables = grouped[category];

      for (const variable of variables) {
        const existingValue = migratedVars[variable.name];

        // If we have a migrated value, use it and show a checkmark
        // Allow empty strings for optional variables
        if (existingValue !== undefined && existingValue !== null &&
            (existingValue !== '' || !isRequired(variable, mode))) {
          values[variable.name] = existingValue;
          const displayValue = existingValue.length > 50 ? existingValue.substring(0, 50) + '...' : existingValue;
          console.log(chalk.green(`‚úì ${variable.name}: ${displayValue || '(empty)'}`));
        } else {
          // Prompt for value - pass collected values for smart suggestions
          const value = await promptForVariable(variable, mode, existingValue, values);
          values[variable.name] = value;
        }
      }
    }

    // Step 4: Generate and save file
    console.log(chalk.bold.blue('\nüíæ Saving environment file...\n'));

    const content = generateEnvFile(values, mode);
    fs.writeFileSync(envFilePath, content, 'utf-8');

    console.log(chalk.green(`‚úì Environment file saved to: ${envFilePath}`));
    console.log(chalk.gray(`  Lines: ${content.split('\n').length}`));
    console.log(chalk.gray(`  Version: ${ENV_VERSION}`));
    console.log(chalk.gray(`  Variables: ${ENV_VARIABLES.length}`));

    // Step 5: Show next steps
    console.log(chalk.bold.blue('\nüìã Next steps:\n'));

    if (mode === 'development') {
      console.log(chalk.gray('  1. Start the database:'));
      console.log(chalk.white('     docker compose up -d database'));
      console.log(chalk.gray('  2. Start development servers:'));
      console.log(chalk.white('     cd backend && npm run dev'));
      console.log(chalk.white('     cd frontend && npm run dev'));
    } else {
      console.log(chalk.gray('  1. Build the containers:'));
      console.log(chalk.white('     docker compose -f docker-compose.prod.yml build'));
      console.log(chalk.gray('  2. Start the services:'));
      console.log(chalk.white('     docker compose -f docker-compose.prod.yml up -d'));
      console.log(chalk.gray('  3. Check logs:'));
      console.log(chalk.white('     docker compose -f docker-compose.prod.yml logs -f'));
    }

    console.log(chalk.green('\n‚ú® Setup complete!\n'));
  } catch (error) {
    if (error.name === 'ExitPromptError') {
      // User pressed Ctrl+C
      console.log(chalk.yellow('\n\n‚ö†Ô∏è  Setup interrupted.'));
      console.log(chalk.gray('Run the script again to complete setup.'));
      process.exit(0);
    } else {
      console.error(chalk.red('\n‚ùå Error:'), error.message);
      if (error.stack) {
        console.error(chalk.gray(error.stack));
      }
      process.exit(1);
    }
  }
}

// Handle Ctrl+C gracefully
process.on('SIGINT', () => {
  console.log(chalk.yellow('\n\n‚ö†Ô∏è  Setup interrupted.'));
  console.log(chalk.gray('Run the script again to complete setup.'));
  process.exit(0);
});

main();
